DynWorker
=========

A DynWorker is a special kind of WebWorker. When I first looked at WebWorkers,
I was trying to use them in my [MCR][1] project. My restrictions, mainly
platform-related, on MCR meant that the current model of WebWorkers cannot be
used. In a word, my problem with WebWorkers is that they are *file-based*.

[1]: https://github.com/passcod/mcr

A WebWorker executes a piece of JS asynchronously from the "main" script. This
piece of JS resides in a file. That was my problem: I wanted something more
like Ruby threads, namely the ability to have the worker logic *inline*.

The Problem
-----------

For a while, I tried to circumvent the file-based nature of WebWorkers, going
as far as hijacking an XHR request to create a virtual file... but to no avail.
However, I returned with two "problems" (other than being file-based) with the
WebWorkers:

 - __One file, one script, one functionality.__ Ok, so you can have messaging
   back and forth between the worker and the parent script, but that's still
   limited. You still have the one file that does one thing, and another file
   that does something else. But what if you have two very similar processes?
   Are you going to have to very similar files? Are you going to have one file
   with a "switch"? The decision can be tricky...
 
 - __Performance: Loading extra files.__ That's the big one. *You need to
   load an extra file.* Let me rephrase that: in our times of fierce
   optimization in terms of loading speed (think JSMin & Google Closure Compiler,
   think concatenation, think Yepnope.js), using a WebWorker requires to load
   one (or more) extra files *without any chance of concatenation or similar
   optimization*.


The Solution
------------

So, now you're thinking I've got a solution to both these problems. Nope. Sorry.
DynWorker alleviates these problems *a bit*. Just a bit.

 + __One file, many scripts, infinite possibilities.__ That might be over the top.
   But it's pretty much what DynWorker is. DynWorker is a kind of library on top
   of WebWorker. When you create a DynWorker, you do not specify a file. Instead,
   you inject functions, objects, and data into the worker and let them run.
 
 + __One single file. That's it.__ That might actually be a cons. To use DynWorker,
   you need to include `dynworker.js` through a script tag (statically or dynamically)
   onto the page. Minification is OK. Concatenation is not. That's because a DynWorker
   runs itself. Wait -- Wha? Yup: `new DynWorker();` is (roughly) the same as
   `new Worker("dynworker.js");`. So when you load the DynWorker library, that's it:
   there's no more file to fetch, it's already cached by the browser. Awesome.


The Code
--------

Enough talk already! Where's the code?

    var worker = new DynWorker();
    
    worker.inject(function(arg) {
      var result = "Do something awesome here";
      
      DynWorker.send(result); // Send it up
    }, "fooBar");
    
    worker.receive(function(message) {
      // Display and strike awe
    });
    
    
    worker.run("fooBar", ["argument"]);

Cool! But what if my function's already named? Well, it depends:

    // We'll parse that name:
    
    function fooBar(arg) {
      // ...
    }
    
    
    // But not that one:
    
    var fooBar = function(arg) {
      // ...
    }
    
    // Yeah, we're as sorry as you :(

Enjoy!
